% !Rnw weave = knitr
%% TO add package copy into /usr/local/texlive/2010basic/texmf-dist/tex/latex/base/ .sty
\documentclass[a4paper,12pt]{report}



\usepackage[]{graphicx}\usepackage[]{color}
%% maxwidth is the original width if it is less than linewidth
%% otherwise use linewidth (to make sure the graphics do not exceed the margin)
\makeatletter
\def\maxwidth{ %
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother
%% maxwidth is the original width if it is less than linewidth
%% otherwise use linewidth (to make sure the graphics do not exceed the margin)


\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}
\newcommand{\hlnum}[1]{\textcolor[rgb]{0.686,0.059,0.569}{#1}}%
\newcommand{\hlstr}[1]{\textcolor[rgb]{0.192,0.494,0.8}{#1}}%
\newcommand{\hlcom}[1]{\textcolor[rgb]{0.678,0.584,0.686}{\textit{#1}}}%
\newcommand{\hlopt}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hlstd}[1]{\textcolor[rgb]{0.345,0.345,0.345}{#1}}%
\newcommand{\hlkwa}[1]{\textcolor[rgb]{0.161,0.373,0.58}{\textbf{#1}}}%
\newcommand{\hlkwb}[1]{\textcolor[rgb]{0.69,0.353,0.396}{#1}}%
\newcommand{\hlkwc}[1]{\textcolor[rgb]{0.333,0.667,0.333}{#1}}%
\newcommand{\hlkwd}[1]{\textcolor[rgb]{0.737,0.353,0.396}{\textbf{#1}}}%

\usepackage{framed}
\makeatletter
\newenvironment{kframe}{%
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\definecolor{shadecolor}{rgb}{.97, .97, .97}
\definecolor{messagecolor}{rgb}{0, 0, 0}
\definecolor{warningcolor}{rgb}{1, 0, 1}
\definecolor{errorcolor}{rgb}{1, 0, 0}
\newenvironment{knitrout}{}{} % an empty environment to be redefined in TeX

\usepackage{alltt}


\usepackage[utf8]{inputenc}
\usepackage[cyr]{aeguill}
\usepackage[francais]{babel}
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}


\begin{document}

\section*{Exercice 1}





On centre tout d'abord la matrice X à l'aide de la matrice de centrage Q8, ça nous servira plus tard :
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{X} \hlkwb{=} \hlstd{Q8} \hlopt{%*%} \hlstd{X}
\end{alltt}
\end{kframe}
\end{knitrout}
On calcule la matrice des distances euclidiennes D2 :
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{D2} \hlkwb{=} \hlkwd{as.matrix}\hlstd{(}\hlkwd{dist}\hlstd{(X))}
\hlstd{D2} \hlkwb{=} \hlstd{D2}\hlopt{^}\hlnum{2}
\end{alltt}
\end{kframe}
\end{knitrout}
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{D2}
\end{alltt}
\begin{verbatim}
##       1     2     3     4     5     6     7     8
## 1  0.00 37.25 67.25  1.00  1.00 55.25  1.25 58.25
## 2 37.25  0.00  4.50 48.25 31.25  2.50 36.50  2.50
## 3 67.25  4.50  0.00 81.25 58.25  1.00 65.00  1.00
## 4  1.00 48.25 81.25  0.00  2.00 67.25  1.25 72.25
## 5  1.00 31.25 58.25  2.00  0.00 46.25  0.25 51.25
## 6 55.25  2.50  1.00 67.25 46.25  0.00 52.00  2.00
## 7  1.25 36.50 65.00  1.25  0.25 52.00  0.00 58.00
## 8 58.25  2.50  1.00 72.25 51.25  2.00 58.00  0.00
\end{verbatim}
\end{kframe}
\end{knitrout}
Après avoir obtenu cette précieuse matrice, on peut calculer la matrice des produits scalaires de 2 façons :
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{W} \hlkwb{=} \hlstd{X} \hlopt{%*%} \hlkwd{t}\hlstd{(X)}
\end{alltt}
\end{kframe}
\end{knitrout}

Mais normalement, on n'aurait pas accès à X directement, il faut la déduire de la matrice des distances euclidiennes :
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{W} \hlkwb{=} \hlstd{(}\hlopt{-}\hlnum{1}\hlopt{/}\hlnum{2}\hlstd{)}\hlopt{*}\hlstd{Q8} \hlopt{%*%} \hlstd{D2} \hlopt{%*%} \hlstd{Q8}
\end{alltt}
\end{kframe}
\end{knitrout}

Il reste à vérifier que W soit semi définie-positive, pour savoir si la matrice des distances était bien euclidienne :
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{L} \hlkwb{=} \hlkwd{eigen}\hlstd{(W)}\hlopt{$}\hlstd{values}
\hlstd{L}
\end{alltt}
\begin{verbatim}
## [1]  1.114606e+02  1.758189e+00  1.100935e-14 -3.346521e-16 -9.500733e-16
## [6] -1.069879e-15 -1.845951e-15 -6.005347e-15
\end{verbatim}
\end{kframe}
\end{knitrout}
W est bien semi définie-positive, on va juste arrondir à zero les valeurs négatives très petites, et diagonaliser L :

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{L[L}\hlopt{<}\hlnum{0}\hlstd{]} \hlkwb{=} \hlnum{0}
\hlstd{L} \hlkwb{=} \hlkwd{diag}\hlstd{(L)}
\hlstd{L}
\end{alltt}
\begin{verbatim}
##          [,1]     [,2]         [,3] [,4] [,5] [,6] [,7] [,8]
## [1,] 111.4606 0.000000 0.000000e+00    0    0    0    0    0
## [2,]   0.0000 1.758189 0.000000e+00    0    0    0    0    0
## [3,]   0.0000 0.000000 1.100935e-14    0    0    0    0    0
## [4,]   0.0000 0.000000 0.000000e+00    0    0    0    0    0
## [5,]   0.0000 0.000000 0.000000e+00    0    0    0    0    0
## [6,]   0.0000 0.000000 0.000000e+00    0    0    0    0    0
## [7,]   0.0000 0.000000 0.000000e+00    0    0    0    0    0
## [8,]   0.0000 0.000000 0.000000e+00    0    0    0    0    0
\end{verbatim}
\end{kframe}
\end{knitrout}

Matrice des vecteurs propres :
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{V} \hlkwb{=} \hlkwd{eigen}\hlstd{(W)}\hlopt{$}\hlstd{vectors}
\end{alltt}
\end{kframe}
\end{knitrout}







\begin{verbatim}


1. distX = as.matrix(X)
    distX = distX ^2
  
2. Méthode 1 
  XC = scale(X, scale=T)
  W = XC\%*\%t(XC)
  
  Méthode 2 
  QN = diag(nrow(X)) - matrix(1, nrow(X), nrow(X))/nrow(X)
  W = -1/2*QN\%*\%distX\%*\%QN
  
3. Pour vérifier si elle est définie semi-positive, il suffit de vérifier que les valeurs propres soient positives ce qui est le cas car on peut considérer que -1.37*10^-17 et -2.45*10^-16 sont des valeurs nulles. 
eigen(W)

4. L = eigen(W)$values
  L = diag(nrow(X))*L
  
  V = eigen(W)$vectors
  
5. C = V\%*\%sqrt(L)
  pas oublier de retirer les NaN
  
  plot(C)
  idem à biplot(princomp(X))
  
\end{verbatim}


\begin{verbatim}
m = as.vector(mutation)
b = cmdscale(mutation, 2, T)
c = as.vector(dist(b$points))
plot(b,c) problème mais on est pas loin 
qualité à calculer avec les valeurs propres b[,1]$eigen etc... / sum 

on refait de même avec cmdscale(mutation, 3, T) jusqu'à 5 

\end{verbatim}

\section*{Exercice 2} 

\subsection*{Iris}

\subsubsection*{Question 1 - Différents nombres de partiton}

\includegraphics[width=\textwidth]{ex2_iris_1.png}


Premièrement, nous remarquons que les partitions n'ont pas toutes le même nombre d'éléments. 
Ensuite, elle varie suivant le nombre de partitions. En effet, nous pourrions penser qu'entre eux 3 et 4 partitions, l'ajout d'une partition subdiviserait une partition déjà existante. Comme le montre les graphes ci dessous cela n'est pas le cas. En effet les 3 partitions de droit pour K=4 ne sont pas pas contenus dans entièrement 2 partitions de K=3. Toutes les partitions sont redéfinis à chaque fois que nous augmontons le nombre. 
Nous savons qu'il existe 3 espèces distinctes d'Iris représentées la représentation avec K=3 représente assez fidélement les 3 espèces. 
\subsubsection*{Question 2 - Stabilité des partitions}

De plus, même pour un même K, dans notre cas k=3, les partitions peuvent changer. Ici, nous avons deux cas différents avec des inerties de classes de 78.9 ou 143. Cela est du au choix aléatoire des centres au début de l'algorithme, nous tombons parfois sur un minima local. Cela une partition correspond à la classification selon les espéces il s'agit de celle avec le miminum d'inertie intra-classes

\includegraphics[width=0.7\textwidth]{ex2_iris_2.png}

 
\subsubsection*{Question 3 - Nombre de partitions optimales}

\begin{verbatim}
$test <- matrix(0, 9, 100)$
$for(j in 1:9){
  for(i in 1:100){
    test[j, i] = kmeans(iris, j+1)$tot.withinss
  }
}$
apply(test, 1, min)
\end{verbatim}

\includegraphics[width=0.4\textwidth]{ex2_iris_3.png}


La solution optimale semble être en 3 classes. Pourtant celle-ci n'est pas flagrante avec le tableau des minimums des inerties. La méthode du coude ne fonctionne pas très bien, elle ne fait pas apparaitre de coude. Le minimum d'inertie de  fait que diminuer en fonction du nombre de classes. 
Une solution serait de pénaliser un grand nombre de classes par le nombre d'individus présents dans la classe.

\subsubsection*{Question 4 - Partitions réelles}

\includegraphics[width=0.7\textwidth]{ex2_iris_4.png}

La première espèce (setosa) est bien différenciée suivant la méthode des centre mobiles alors que les espèces versicolor et verginia se chevauchent il est alors plus difficile pour l'algorithme de les différencer efficacement. 

\subsection*{Crabs}

\includegraphics[width=0.3\textwidth]{ex2_crab_1.png}

Selon le graphe ci dessous de la méthode du coude, le nombre optimal de partition est 3. Le coude est bien visible pour les crabes. Cela est en contradiction avec la classification selon l'espèce et le sexe qui donne 4 classes diffèrentes.  


\includegraphics[width=0.5\textwidth]{ex2_crab_3.png}

J'ai donc effectué les 2 classifications avec 3 et 4 partitions. 

\includegraphics[width=0.5\textwidth]{ex2_crab_4.png}

Nous retrouvons à peu près les mêmes classes avec la partitions des centre mobiles ou suivant la classification suivant l'espèce et le sexe. Cela montre bien que les autres variables permettent de déterminer l'espèce et le sexe d'un crabe. 

\subsection*{Mutations}
\begin{verbatim}
res = kmeans(mutations2, 2)
plot(cmdscale(mutations), col=res$cluster)

Avec 3 vert au milieu des noirs 

4 cluster seulement un point dans le dernier


tableau de contingence pour comparer les partitions table(res$cluster, res2$cluster)
\end{verbatim}

Les

\end{document}
